\documentclass[12pt]{article}
\usepackage{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{listings}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{appendix}
\usepackage{multicol}

\theoremstyle{definition}
\newtheorem{thm}{Théorème}[section]
\newtheorem{lemme}[thm]{Lemme}
\newtheorem{remarque}[thm]{Remarque}
\newtheorem{defi}[thm]{Définition}
\newtheorem{propo}[thm]{Proposition}

\renewcommand{\a}{\alpha}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} 
\newcommand{\F}{\mathbb{F}} 
\newcommand{\K}{\mathbb{K}} 

\title{Projet - Wave}
\author{Lansade Suzanne}
\author{Palandjian Eva}

\begin{document}

\begin{titlepage}

\center

\textsc{\LARGE Université de Bordeaux}\\[2.0cm]
\textsc{\Large Master 2 : Cryptologie et Sécurité Informatique}\\[0.5cm] 
\textsc{\large Projet de fin d'études}\\[1.2cm] 

\HRule \\[0.4cm]
{ \huge \bfseries Wave - Un procédé de signature \\ à base de codes correcteurs}\\[0.3cm] 
\HRule \\[1.3cm]


\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
Suzanne \textsc{Lansade}\\
Eva \textsc{Palandjian}\\
\end{flushleft}
\end{minipage}
~
\begin{minipage}{0.4\textwidth}
\begin{flushright} \large
\emph{Encadrant:} \\
Gilles \textsc{Zemor}
\end{flushright}
\end{minipage}\\[2cm]

\begin{large}
Février, 2020
\end{large}

\vspace{0.5in}

\includegraphics [scale=0.2]{Universite_Bordeaux.jpg}

\end{titlepage}

\newpage
\tableofcontents
\newpage

\section*{Introduction}
\addcontentsline{toc}{section}{\protect\numberline{}Introduction}

- passage au post-quantique \\
- appel d'offre NIST \\
	-> tableau : aucun code correcteur en signatures \\
- dur de trouver l'ensemble des syndromes facilement décodable \\
- dur de créer une fonction de hachage qui envoie m dans l'ensemble des syndromes possibles \\
- problème du décodage NP-complet \\
- mot y de syndrome s est associé à un unique mot de code c le plus proche de y \\
quand on chiffre -> ne pose pas de problème \\
quand on signe -> pose un problème car il est dur de trouver un syndrome de cette sorte \\
la solution Wave est d'enlever la restriction au mot le plus proche \\
Nous allons détailler le schéma de signature Wave et détailler sa sécurité. \\

\section{Le schéma de signature Wave}
Pour répondre aux problèmes : \\

- Des codes UV-généralisés \\
- Des fonctions GPV en moyenne \\
- Un schéma de signature de type hash et signe utilisant ces codes \\

\subsection{La famille de codes (U,U+V)-généralisés}
Définition des codes (U,U+V)-généralisés: \\
- Comment les créer  FAIT \\
- Choix des paramètres a,b,c,d \`A DETAILLER \\
- Liens entre les matrices des codes U et V et du code UV FAIT \\
- Les dimensions et différents paramètres  EN COURS \\
- Calcul du hull ==> q > 2 TODO \\
- ...? \\


\begin{defi} Soient $U$ et $V$ deux codes de même longueur $n/2$ et de dimension respectives $k_u$ et $k_v$. Un code $(U,U+V)$ est un code de longueur $n$ et de dimension $k=k_u+k_v$ et tel que :
\begin{center}
$(U,U+V) = \{(u,u+v)$ tel que $u \in U$ et $v \in V \}$
\end{center}
\end{defi}

\begin{defi} \label{UV-normalise} (codes $(U,U+V)$-généralisés) Soient $n$ un entier pair et $a$,$b$,$c$,$d$ quatres vecteurs de $\F_q^{n/2}$ tels que pour tout $i \in {1,n/2}$ :
$$ a_ic_i \neq 0 $$
$$ a_id_i - b_ic_i \neq 0 $$
Soient U et V deux codes définis comme précédemment. Le code $(U,U+V)$-généralisé correspond à l'ensemble :
\begin{center}
$\{(a.u + b.v, c.u + d.v)$ tel que $u \in U$ et $v \in V \}$
\end{center}
où $x.y$ est le produit coordonnée par coordonnée des $x_i$ et $y_i$.
\end{defi}

\begin{remarque}
Dans la suite, on prend $a$,$b$,$c$,$d$ tels que 
$$ a_id_i - b_ic_i = 1 \text{ pour tout } i \in {1,n/2}.$$ 
\end{remarque}

\begin{propo} Soient $U$, $V$, $a$, $b$, $c$ et $d$ définis comme précédemment. Soit $UV$ le code $(U,U+V)$-généralisé associé. Alors
$$ k = \dim UV = k_u + k_v.$$
De plus soient $G_U \in \F_q^{k_u \times n/2}$ (respectivement $G_V \in \F_q^{k_v \times n/2}$) et $H_U \in \F_q^{(n/2-k_u) \times n/2}$ (respectivement $H_V \in \F_q^{(n/2-k_v) \times n/2}$) les matrices génératrices et de parité des codes $U$ et $V$. Soient $A$, $B$, $C$, $D$ de $\F_q^{n \times n}$ les matrices diagonales de diagonales respectives les vecteurs $a$, $b$, $c$ et $d$.  \\
\vspace{0.2in}
Alors la matrice de $\F_q^{(k_u + k_v) \times n}$: 

\vspace{0.1in}

$$
G := 
\begin{pmatrix}
\begin{array}{c|c}
G_uA & G_uC \\
 \hline 
G_vB & G_VD \\
\end{array} \\
\end{pmatrix}
$$

\noindent et la matrice $\F_q^{(n - k_u - k_v) \times n}$:

\vspace{0.1in}
$$ 
H :=
\begin{pmatrix}
\begin{array}{c|c}
H_uD & -H_uB \\
 \hline 
-H_vC & H_VA \\
\end{array} \\
\end{pmatrix}
$$
\vspace{0.1in}

\noindent sont des matrices génératrices et de parité du code $UV$. 
\end{propo}

\begin{proof}[Preuve]
Remarquons d'abord que G engendre bien le code $UV$. Remarquons aussi que 

$$
\begin{pmatrix}
\begin{array}{c|c}
G_uA & G_uC \\
 \hline 
G_vB & G_VD \\
\end{array} \\
\end{pmatrix}
= 
\begin{pmatrix}
\begin{array}{c|c}
G_u & 0 \\
 \hline 
0 & G_V \\
\end{array} \\
\end{pmatrix} 
\begin{pmatrix}
\begin{array}{c|c}
A & C \\
 \hline 
B & D \\
\end{array} \\
\end{pmatrix}
$$

Par définition des matrices $G_V$ et $G_U$, la matrice $ 
\begin{pmatrix}
\begin{array}{c|c}
G_u & 0 \\
 \hline 
0 & G_V \\
\end{array} \\
\end{pmatrix} $ est de rang $k_u + k_v$. De plus les matrices $A$, $B$, $C$, $D$ étant diagonales, le déterminant de la matrice $\begin{pmatrix}
\begin{array}{c|c}
A & C \\
 \hline 
B & D \\
\end{array} \\
\end{pmatrix}$
est le produit des $(a_id_i - b_ic_i)$ pour $i \in {1, n/2}$, et donc non-nul par définition des vecteurs $a,b,c,d$. On a donc bien $k = k_u + k_v$. \\
On remarque aussi que $GH^T = 0$ et que $H$ est de rang plein par le même raisonnement que précédemment, ce qui conclut la preuve.
\end{proof}

\subsection{Le principe de signature}
Un schéma hash et signe utilisant la fonction syndrome comme fonction à sens unique : \\
- Définition des fonctions GPVM, un couple (Trapdoor, InvertAlg) où trapdoor est un algo poly proba renvoyant une matrice de parité et la trappe associée, et où InvertAlg est un algo poly proba prenant en entrée la trappe et renvoyant l'inverse de la fonction syndrome. \\
De plus, ces fonctions sont (1) bien distribuées, (2) sans fuite d'info en moyenne, (3) sens unique sans la trappe \\
- Le schéma : un algo signe et un algo verify. \\

Notre schéma de signature utilisera donc les codes $(U,U+V)$-généralisés et la fonction syndrôme comme fonction à sens unique, sous l'hypothèse de la difficulté de résoudre le problème du décodage. \\

Nous allons définir la notion de fonctions GPV en moyenne (GPVM). Pour cela, introduisons d'abord la notion de distance statistique.

\begin{defi}
Soient $X$ et $Y$ deux variables aléatoires à valeurs dans le même espace $\epsilon$. 
Soient $\mathcal{D}_X$ et $\mathcal{D}_Y$ leurs distributions respectives. On définit la distance statistique entre ces deux distributions comme :
$$ \rho(\mathcal{D}_X,\mathcal{D}_Y) := \frac{1}{2} \sum_{x \in \epsilon} |\mathcal{D}_X(x) \mathcal{D}_Y(x)|.$$
\end{defi}

\begin{defi} (Fonctions GPVM). On appelle fonction GPV en moyenne une paire d'algorithmes (\verb|Trapdoor|,\verb|InvertAlg|) ainsi qu'un triplet de fonctions ($n(\lambda),k(\lambda),\omega(\lambda)$) en fonction d'un paramètre de sécurité $\lambda$, tels que :
\begin{itemize}
\item \verb|Trapdoor| est un algorithme probabiliste et polynomial en $1^\lambda$ et renvoyant le couple $(H,T)$ où $H \in \F_q^{(n-k) \times n}$ de rang $n-k$ et $T$ est la trappe associée.
\item \verb|InvertAlg| est un algorithme probabiliste et polynomial prenant en entrée la trappe $T$ et un syndrôme $s \in \F_q^{n-k}$, et renvoyant $e \in \F_q^{n}$ de poids $\omega$ tel que $eH^T = s$.
\end{itemize}
De plus, pour \textit{presque toutes} matrice $H$ renvoyée par \verb|Trapdoor|, la fonction est :
\begin{enumerate}
\item bien distribuée : \\
$\rho(eH^T,s) \in \text{negl}(\lambda)$ où $e$ est pris uniformément dans l'ensemble des mots de poids $\omega$ et de longueur $n$ et $s$ est pris uniformément dans $\F_q^{n-k}$. 
\item sans fuite d'information \textit{en moyenne} : \\
$ \rho(\verb|InvertAlg|(s,T),e) \in \text{negl}(\lambda)$ où $e$ est pris uniformément dans l'ensemble des mots de poids $\omega$ et de longueur $n$ et $s$ est pris uniformément dans $\F_q^{n-k}$. 
\item \`A sens unique sans la trappe : \\
Pour tout algorithme probabiliste polynomial $\mathcal{A}$, on a 
$$\mathbb{P}(\mathcal{A}(H,s) = e | eH^T = s) \in \text{negl}(\lambda).$$
\end{enumerate}
C'est une définition relaxée des fonctions GPV.
\end{defi}

Nous pouvons maintenant définir notre système de signature.
\begin{multicols}{2}
\begin{flushleft}
$\verb|Sign|^{sk}(s)$:\\
	$\quad$ e $\leftarrow$  \verb|InvertAlg|(s,T) \\
	$\quad$ \verb|renvoie| e
\end{flushleft}
\begin{flushleft}
$\verb|Verify|^{pk}(s,e')$: \\
	$\quad \verb| Si | e'H^T = s \verb| et | |e'| = \omega $ \\
	$\quad \quad$ \verb|renvoie 1| \\
	$\quad$ \verb|renvoie 0|
\end{flushleft}
\end{multicols}



\subsection{Le décodage avec trappe}
Détail de l'algorithme invertAlg avec utilisation de la trappe: \\
- Conditions sur le poids de e: \\
--> facile \\
--> facile avec trappe \\
--> difficile \\
- Inverser le syndrome sur le code UV <==> inverser le syndrome sur U et sur V et prendre son image par Phi. \\
- Prendre un ev par un algo de décodage quelconque, utiliser les propriétés du code UV pour en déduire un eu, vérifier le poids de e, recommencer. \\
- Différences gros poids et petits poids \\

En partant de l'hypothèse que la matrice de parité $\mathbf{H}$ du code $(U,U+V)$-généralisé ressemble à une matrice aléatoire, la difficulté de créer une fausse signature sans connaître la trappe $\mathbf{T}$ est exactement celle de résoudre le problème du décodage d'un code aléatoire, que l'on sait difficile. Nous allons expliciter dans cette section l'algorithme d'inversion de la fonction syndrôme, et discuter sa difficulté en fonction du poids $\omega$ de $e$. \\

Notons $\mathcal{S}_{\omega,n}$ l'ensemble des mots de poids $\omega$ et de longueur $n$. On notera $\mathcal{S}_{\omega}$ s'il n'y a pas d'ambiguité sur la longueur. On rappelle que l'agorithme \verb|InvertAlg| cherche à inverser la fonction syndrôme : 
$$\begin{array}{ccccc}
f_{\omega,\mathbf{H}} & : & \mathcal{S}_{\omega,n} & \to & \F_q^{n-k} \\
 & & \mathbf{e} & \mapsto & \mathbf{eH^T} \\
\end{array}$$

On rappelle que la fonction $f_{\omega,\mathbf{H}}$ avec $\mathbf{H} \in \F_q^{(n-k)\times n}$ s'inverse génériquement si $\omega \in \{\omega_{easy}^-,\omega_{easy}^+\}$, où :
$$ \omega_{easy}^- := \frac{q-1}{q}(n-k) \qquad \text{ et }\qquad  \omega_{easy}^+\} := k + \frac{q-1}{q}(n-k).$$

\begin{proof}[Preuve] TODO
\end{proof}


On rappelle aussi que la fonction $f_{\omega,\mathbf{H}}$ admet un inverse pour toute entrée $s \in \F_q^{n-k}$ si $\omega \in \{\omega^-,\omega^+\}$, où :
$$ \omega^- := ??? \qquad \text{ et }\qquad  \omega^+\} := ???.$$

\begin{proof}[Preuve] TODO
\end{proof}


Nous voulons donc un moyen d'inverser la fonction syndrôme pour $\omega \in \{\omega_{UV}^-,\omega_{UV}^+\}$ avec $\omega_{UV}^-$ et $\omega_{UV}^+$ tels que :

$$\{\omega_{easy}^-,\omega_{easy}^+\} \subsetneq \{\omega_{UV}^-,\omega_{UV}^+\} \subset  \{\omega^-,\omega^+\}$$

INSERER SCHEMA !! \\

Afin d'expliciter le décodage, introduisons la fonction :

$$\begin{array}{ccccc}
\varphi_{\mathbf{a},\mathbf{b},\mathbf{c},\mathbf{d}} & : & \F_q^{n/2} \times  \F_q^{n/2} & \to & \F_q^{n/2} \times  \F_q^{n/2} \\
 & & (\mathbf{x} , \mathbf{y}) & \mapsto &  (\mathbf{a}.\mathbf{x} + \mathbf{b}.\mathbf{y}, \mathbf{c}.\mathbf{x} + \mathbf{d}.\mathbf{y}) \\
\end{array}$$

Si cette fonction respecte les conditions sur les vecteurs $\mathbf{a},\mathbf{b},\mathbf{c},\mathbf{d}$ définies dans la définition \ref{UV-normalise}, on dit qu'elle est UV-normalisée. Dans ce cas on peut vérifier qu'elle est bijective d'inverse :

$$\begin{array}{ccccc}
\varphi^{-1}_{\mathbf{a},\mathbf{b},\mathbf{c},\mathbf{d}} & : & \F_q^{n/2} \times  \F_q^{n/2} & \to & \F_q^{n/2} \times  \F_q^{n/2} \\
 & & (\mathbf{x} , \mathbf{y}) & \mapsto &  (\mathbf{d}.\mathbf{x} - \mathbf{b}.\mathbf{y}, -\mathbf{c}.\mathbf{x} + \mathbf{a}.\mathbf{y}) \\
\end{array}$$

Ainsi, pour chaque vecteur $\mathbf{e}$ de $\F_q^n$, on peut associer deux vecteurs $\mathbf{e_U}$ et $\mathbf{e_V}$ de $\F_q^{n/2}$ tels que 
$$ (\mathbf{e_U},\mathbf{e_V}) = \varphi^{-1}_{\mathbf{a},\mathbf{b},\mathbf{c},\mathbf{d}}(\mathbf{e}).$$

\begin{propo} Inverser $f_{\omega,\mathbf{H}}$ pour un certain $\mathbf{s} \in F_q^{n-k}$ est équivalent à trouver $\mathbf{e} \in \F_q^n$ tel que:
$$ \mathbf{e}_U\mathbf{H}_U^T = \mathbf{s}^U \qquad \text{et} \qquad \mathbf{e}_V\mathbf{H}_V^T = \mathbf{s}^V $$
où $\mathbf{s} = (\mathbf{s}^U, \mathbf{s}^V)$ avec $\mathbf{s}^U \in \F_q^{n/2-k_U}$ et $\mathbf{s}^V \in \F_q^{n/2-k_V}$.
\end{propo}

\begin{proof}[Preuve] TODO
\end{proof}

Ainsi, on on aura : \\
\begin{flushleft}
\verb|InvertAlg|$(\mathbf{s},\mathbf{T}) : $\\
$\qquad (\mathbf{s}_U, \mathbf{s}_V) = s $\\
$\qquad \mathbf{e}_U = \verb|DECODE_U|(\mathbf{s}_U) $\\
$\qquad \mathbf{e}_V = \verb|DECODE_V|(\mathbf{s}_V)$ \\
$\qquad \verb|renvoie | \varphi_{\mathbf{a},\mathbf{b},\mathbf{c},\mathbf{d}}(\mathbf{e_U},\mathbf{e_V})$ \\

\end{flushleft}
Si l'on choisit un algorithme générique pour \verb|DECODE_U| et \verb|DECODE_V|, alors nous obtiendrons un vecteur $\mathbf{e}$ de poids $\omega \ in \{\omega_{easy}^-,\omega_{easy}^+\}$. Non allons montrer comment utiliser les propriétés des codes $(U,U+V)$-généréralisés pour permettre un décodage hors de cet intervalle. 

\begin{remarque} Pour tout $\mathbf{e} = \varphi_{\mathbf{a},\mathbf{b},\mathbf{c},\mathbf{d}}(\mathbf{e_U},\mathbf{e_V})$, on a pour tout $i \in \{1,n/2\}$ :
\begin{center}

$\left \{
\begin{array}{rcl}
a_i\mathbf{e}_U(i) + b_i\mathbf{e}_V(i) &=& \mathbf{e}(i) \\
c_i\mathbf{e}_U(i) + d_i\mathbf{e}_V(i) &=& \mathbf{e}(i+n/2) 
\end{array}
\right.$
\end{center}

Choisir la valeur de $\mathbf{e}_U$ en fonction de la valeur de $\mathbf{e}_V$ nous permettras donc d'influer sur le poids de $\mathbf{e}$. On aura alors :

\begin{flushleft}
\verb|InvertAlg|$(\mathbf{s},\mathbf{T}) : $\\
$\qquad (\mathbf{s}_U, \mathbf{s}_V) = s $\\
$\qquad \mathbf{e}_V = \verb|DECODE_V|(\mathbf{s}_V)$ \\
$\qquad \mathbf{e}_U = \verb|DECODE_U|(\mathbf{s}_U, \mathbf{e}_V) $\\
$\qquad \verb|renvoie | \varphi_{\mathbf{a},\mathbf{b},\mathbf{c},\mathbf{d}}(\mathbf{e_U},\mathbf{e_V})$ \\

\end{flushleft}

\end{remarque}


\begin{remarque} Fonction de hash
\end{remarque}

\subsection{Implémentation et choix de paramètres}
TODO \\

\section{Uniformisation des signatures et syndromes}

\subsection{Une fuite d'information}
- Malheureusement, fuite d'information en raison des correspondance entre e[i] et e[i+n/2] ! \\
- Calcul de proba \\
- Pourquoi c'est problématique \\ 

\subsection{La méthode du rejet}
Idée générale : On attend pour que les sorties aient l'air uniforme (soient suffisemment proches de l'uniforme): \\
- On choisit ev de façon a ce qu'il soit uniforme dans son ensemble \\
- On met des conditions de rejet sur eu en fonction de ev pour que eu ait l'air uniforme \\
- On obtient un e qui a l'air uniforme \\

\subsection{Estimation du nombre de rejet}
TODO \\

\subsection{Une famille de fonctions uniformément distribuée}
On a donc le point (2) de la definition des fonctions GPV qui est obtenu dans la section précédente. On va montrer le point (1), à savoir, notre famille de fonctions syndrômes est uniformément distribuée avec les codes (U,U+V)-généralisés \\

\section{Sécurité du schéma}

\subsection{Sécurité EUF-CMA}
\subsubsection{Définitions}
\subsubsection{Réduction au problème DOOM}
\subsubsection{Et la fonction de hachage ?}

\subsection{Indistinguabilité des codes (U,U+V)-généralisés}
Distinguer une matrice de parité d'un code (U,U+V)-généralisé d'une matrice de parité aléatoire. \\
Réduction à un problème NP-complet. \\
Utilisation de S et P pour masquer les propriétés de la matrice. \\

\section*{Conclusion}
\addcontentsline{toc}{section}{\protect\numberline{}Conclusion}

\newpage


\bibliographystyle{plain}
\bibliography{bibliography}

\end{document}