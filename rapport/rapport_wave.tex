\documentclass[12pt]{article}
\usepackage{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{listings}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{appendix}
\usepackage{multicol}

\theoremstyle{definition}
\newtheorem{thm}{Théorème}[section]
\newtheorem{lemme}[thm]{Lemme}
\newtheorem{remarque}[thm]{Remarque}
\newtheorem{defi}[thm]{Définition}
\newtheorem{propo}[thm]{Proposition}
\newtheorem{nota}[thm]{Notation}

\renewcommand{\a}{\alpha}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} 
\newcommand{\F}{\mathbb{F}} 
\newcommand{\e}{\mathbf{e}} 
\newcommand{\s}{\mathbf{s}} 
\newcommand{\K}{\mathbb{K}} 

\title{Projet - Wave}
\author{Lansade Suzanne}
\author{Palandjian Eva}

\begin{document}

\begin{titlepage}

\center

\textsc{\LARGE Université de Bordeaux}\\[2.0cm]
\textsc{\Large Master 2 : Cryptologie et Sécurité Informatique}\\[0.5cm] 
\textsc{\large Projet de fin d'études}\\[1.2cm] 

\HRule \\[0.4cm]
{ \huge \bfseries Wave - Un procédé de signature \\ à base de codes correcteurs}\\[0.3cm] 
\HRule \\[1.3cm]


\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
Suzanne \textsc{Lansade}\\
Eva \textsc{Palandjian}\\
\end{flushleft}
\end{minipage}
~
\begin{minipage}{0.4\textwidth}
\begin{flushright} \large
\emph{Encadrant:} \\
Gilles \textsc{Zemor}
\end{flushright}
\end{minipage}\\[2cm]

\begin{large}
Février, 2020
\end{large}

\vspace{0.5in}

\includegraphics [scale=0.2]{Universite_Bordeaux.jpg}

\end{titlepage}

\newpage
\tableofcontents
\newpage

\section*{Introduction}
\addcontentsline{toc}{section}{\protect\numberline{}Introduction}

- passage au post-quantique \\
- appel d'offre NIST \\
	-> tableau : aucun code correcteur en signatures \\
- dur de trouver l'ensemble des syndromes facilement décodable \\
- dur de créer une fonction de hachage qui envoie m dans l'ensemble des syndromes possibles \\
- problème du décodage NP-complet \\
- mot y de syndrome s est associé à un unique mot de code c le plus proche de y \\
quand on chiffre -> ne pose pas de problème \\
quand on signe -> pose un problème car il est dur de trouver un syndrome de cette sorte \\
la solution Wave est d'enlever la restriction au mot le plus proche \\
Nous allons détailler le schéma de signature Wave et détailler sa sécurité. \\

\section{Le schéma de signature Wave}
Pour répondre aux problèmes : \\

- Des codes UV-généralisés \\
- Des fonctions GPV en moyenne \\
- Un schéma de signature de type hash et signe utilisant ces codes \\

\subsection{La famille de codes (U,U+V)-généralisés}
Définition des codes (U,U+V)-généralisés: \\
- Comment les créer  FAIT \\
- Choix des paramètres a,b,c,d \`A DETAILLER \\
- Liens entre les matrices des codes U et V et du code UV FAIT \\
- Les dimensions et différents paramètres  EN COURS \\
- Calcul du hull ==> q > 2 TODO \\
- ...? \\


\begin{defi} Soient $U$ et $V$ deux codes de même longueur $n/2$ et de dimension respectives $k_u$ et $k_v$. Un code $(U,U+V)$ est un code de longueur $n$ et de dimension $k=k_u+k_v$ et tel que :
\begin{center}
$(U,U+V) = \{(u,u+v)$ tel que $u \in U$ et $v \in V \}$
\end{center}
\end{defi}

\begin{defi} \label{UV-normalise} (codes $(U,U+V)$-généralisés) Soient $n$ un entier pair et $a$,$b$,$c$,$d$ quatres vecteurs de $\F_q^{n/2}$ tels que pour tout $i \in {1,n/2}$ :
$$ a_ic_i \neq 0 $$
$$ a_id_i - b_ic_i \neq 0 $$
Soient U et V deux codes définis comme précédemment. Le code $(U,U+V)$-généralisé correspond à l'ensemble :
\begin{center}
$\{(a.u + b.v, c.u + d.v)$ tel que $u \in U$ et $v \in V \}$
\end{center}
où $x.y$ est le produit coordonnée par coordonnée des $x_i$ et $y_i$.
\end{defi}

\begin{remarque}
Dans la suite, on prend $a$,$b$,$c$,$d$ tels que 
$$ a_id_i - b_ic_i = 1 \text{ pour tout } i \in {1,n/2}.$$ 
\end{remarque}

\begin{propo} Soient $U$, $V$, $a$, $b$, $c$ et $d$ définis comme précédemment. Soit $UV$ le code $(U,U+V)$-généralisé associé. Alors
$$ k = \dim UV = k_u + k_v.$$
De plus soient $G_U \in \F_q^{k_u \times n/2}$ (respectivement $G_V \in \F_q^{k_v \times n/2}$) et $H_U \in \F_q^{(n/2-k_u) \times n/2}$ (respectivement $H_V \in \F_q^{(n/2-k_v) \times n/2}$) les matrices génératrices et de parité des codes $U$ et $V$. Soient $A$, $B$, $C$, $D$ de $\F_q^{n \times n}$ les matrices diagonales de diagonales respectives les vecteurs $a$, $b$, $c$ et $d$.  \\
\vspace{0.2in}
Alors la matrice de $\F_q^{(k_u + k_v) \times n}$: 

\vspace{0.1in}

$$
G := 
\begin{pmatrix}
\begin{array}{c|c}
G_uA & G_uC \\
 \hline 
G_vB & G_VD \\
\end{array} \\
\end{pmatrix}
$$

\noindent et la matrice $\F_q^{(n - k_u - k_v) \times n}$:

\vspace{0.1in}
$$ 
H :=
\begin{pmatrix}
\begin{array}{c|c}
H_uD & -H_uB \\
 \hline 
-H_vC & H_VA \\
\end{array} \\
\end{pmatrix}
$$
\vspace{0.1in}

\noindent sont des matrices génératrices et de parité du code $UV$. 
\end{propo}

\begin{proof}[Preuve]
Remarquons d'abord que G engendre bien le code $UV$. Remarquons aussi que 

$$
\begin{pmatrix}
\begin{array}{c|c}
G_uA & G_uC \\
 \hline 
G_vB & G_VD \\
\end{array} \\
\end{pmatrix}
= 
\begin{pmatrix}
\begin{array}{c|c}
G_u & 0 \\
 \hline 
0 & G_V \\
\end{array} \\
\end{pmatrix} 
\begin{pmatrix}
\begin{array}{c|c}
A & C \\
 \hline 
B & D \\
\end{array} \\
\end{pmatrix}
$$

Par définition des matrices $G_V$ et $G_U$, la matrice $ 
\begin{pmatrix}
\begin{array}{c|c}
G_u & 0 \\
 \hline 
0 & G_V \\
\end{array} \\
\end{pmatrix} $ est de rang $k_u + k_v$. De plus les matrices $A$, $B$, $C$, $D$ étant diagonales, le déterminant de la matrice $\begin{pmatrix}
\begin{array}{c|c}
A & C \\
 \hline 
B & D \\
\end{array} \\
\end{pmatrix}$
est le produit des $(a_id_i - b_ic_i)$ pour $i \in {1, n/2}$, et donc non-nul par définition des vecteurs $a,b,c,d$. On a donc bien $k = k_u + k_v$. \\
On remarque aussi que $GH^T = 0$ et que $H$ est de rang plein par le même raisonnement que précédemment, ce qui conclut la preuve.
\end{proof}


$q=2$ --> calcul du hull --> fuite d'info. \\
On pose donc $q=3$ pour toute la suite du rapport.

\subsection{Le principe de signature}
Un schéma hash et signe utilisant la fonction syndrome comme fonction à sens unique : \\
- Définition des fonctions GPVM, un couple (Trapdoor, InvertAlg) où trapdoor est un algo poly proba renvoyant une matrice de parité et la trappe associée, et où InvertAlg est un algo poly proba prenant en entrée la trappe et renvoyant l'inverse de la fonction syndrome. \\
De plus, ces fonctions sont (1) bien distribuées, (2) sans fuite d'info en moyenne, (3) sens unique sans la trappe \\
- Le schéma : un algo signe et un algo verify. \\

Notre schéma de signature utilisera donc les codes $(U,U+V)$-généralisés et la fonction syndrôme comme fonction à sens unique, sous l'hypothèse de la difficulté de résoudre le problème du décodage. \\

Nous allons définir la notion de fonctions GPV en moyenne (GPVM). Pour cela, introduisons d'abord la notion de distance statistique.

\begin{defi}
Soient $X$ et $Y$ deux variables aléatoires à valeurs dans le même espace $\epsilon$. 
Soient $\mathcal{D}_X$ et $\mathcal{D}_Y$ leurs distributions respectives. On définit la distance statistique entre ces deux distributions comme :
$$ \rho(\mathcal{D}_X,\mathcal{D}_Y) := \frac{1}{2} \sum_{x \in \epsilon} |\mathcal{D}_X(x) \mathcal{D}_Y(x)|.$$
\end{defi}

\begin{defi} (Fonctions GPVM). On appelle fonction GPV en moyenne une paire d'algorithmes (\verb|Trapdoor|,\verb|InvertAlg|) ainsi qu'un triplet de fonctions ($n(\lambda),k(\lambda),\omega(\lambda)$) en fonction d'un paramètre de sécurité $\lambda$, tels que :
\begin{itemize}
\item \verb|Trapdoor| est un algorithme probabiliste et polynomial en $1^\lambda$ et renvoyant le couple $(H,T)$ où $H \in \F_q^{(n-k) \times n}$ de rang $n-k$ et $T$ est la trappe associée.
\item \verb|InvertAlg| est un algorithme probabiliste et polynomial prenant en entrée la trappe $T$ et un syndrôme $s \in \F_q^{n-k}$, et renvoyant $e \in \F_q^{n}$ de poids $\omega$ tel que $eH^T = s$.
\end{itemize}
De plus, pour \textit{presque toutes} matrice $H$ renvoyée par \verb|Trapdoor|, la fonction est :
\begin{enumerate}
\item bien distribuée : \\
$\rho(eH^T,s) \in \text{negl}(\lambda)$ où $e$ est pris uniformément dans l'ensemble des mots de poids $\omega$ et de longueur $n$ et $s$ est pris uniformément dans $\F_q^{n-k}$. 
\item sans fuite d'information \textit{en moyenne} : \\
$ \rho(\verb|InvertAlg|(s,T),e) \in \text{negl}(\lambda)$ où $e$ est pris uniformément dans l'ensemble des mots de poids $\omega$ et de longueur $n$ et $s$ est pris uniformément dans $\F_q^{n-k}$. 
\item \`A sens unique sans la trappe : \\
Pour tout algorithme probabiliste polynomial $\mathcal{A}$, on a 
$$\mathbb{P}(\mathcal{A}(H,s) = e \;| \;eH^T = s) \in \text{negl}(\lambda).$$
\end{enumerate}
C'est une définition relaxée des fonctions GPV.
\end{defi}

Nous pouvons maintenant définir notre système de signature.
\begin{multicols}{2}
\begin{flushleft}
$\verb|Sign|^{sk}(s)$:\\
	$\quad$ e $\leftarrow$  \verb|InvertAlg|(s,T) \\
	$\quad$ \verb|renvoie| e
\end{flushleft}
\begin{flushleft}
$\verb|Verify|^{pk}(s,e')$: \\
	$\quad \verb| Si | e'H^T = s \verb| et | |e'| = \omega $ \\
	$\quad \quad$ \verb|renvoie 1| \\
	$\quad$ \verb|renvoie 0|
\end{flushleft}
\end{multicols}



\subsection{Le décodage avec trappe}
Détail de l'algorithme invertAlg avec utilisation de la trappe: \\
- Conditions sur le poids de e: \\
--> facile \\
--> facile avec trappe \\
--> difficile \\
- Inverser le syndrome sur le code UV <==> inverser le syndrome sur U et sur V et prendre son image par Phi. \\
- Prendre un ev par un algo de décodage quelconque, utiliser les propriétés du code UV pour en déduire un eu, vérifier le poids de e, recommencer. \\
- Différences gros poids et petits poids \\

En partant de l'hypothèse que la matrice de parité $\mathbf{H}$ du code $(U,U+V)$-généralisé ressemble à une matrice aléatoire, la difficulté de créer une fausse signature sans connaître la trappe $\mathbf{T}$ est exactement celle de résoudre le problème du décodage d'un code aléatoire, que l'on sait difficile. Nous allons expliciter dans cette section l'algorithme d'inversion de la fonction syndrôme, et discuter sa difficulté en fonction du poids $\omega$ de $e$. \\

Notons $\mathcal{S}_{\omega,n}$ l'ensemble des mots de poids $\omega$ et de longueur $n$. On notera $\mathcal{S}_{\omega}$ s'il n'y a pas d'ambiguité sur la longueur. On rappelle que l'agorithme \verb|InvertAlg| cherche à inverser la fonction syndrôme : 
$$\begin{array}{ccccc}
f_{\omega,\mathbf{H}} & : & \mathcal{S}_{\omega,n} & \to & \F_q^{n-k} \\
 & & \mathbf{e} & \mapsto & \mathbf{eH^T} \\
\end{array}$$

On rappelle que la fonction $f_{\omega,\mathbf{H}}$ avec $\mathbf{H} \in \F_q^{(n-k)\times n}$ s'inverse génériquement si $\omega \in \{\omega_{easy}^-,\omega_{easy}^+\}$, où :
$$ \omega_{easy}^- := \frac{q-1}{q}(n-k) \qquad \text{ et }\qquad  \omega_{easy}^+\} := k + \frac{q-1}{q}(n-k).$$

\begin{proof}[Preuve] TODO
\end{proof}


On rappelle aussi que la fonction $f_{\omega,\mathbf{H}}$ admet un inverse pour toute entrée $s \in \F_q^{n-k}$ si $\omega \in \{\omega^-,\omega^+\}$, où :
$$ \omega^- := ??? \qquad \text{ et }\qquad  \omega^+\} := ???.$$

\begin{proof}[Preuve] TODO
\end{proof}


Nous voulons donc un moyen d'inverser la fonction syndrôme pour $\omega \in \{\omega_{UV}^-,\omega_{UV}^+\}$ avec $\omega_{UV}^-$ et $\omega_{UV}^+$ tels que :

$$\{\omega_{easy}^-,\omega_{easy}^+\} \subsetneq \{\omega_{UV}^-,\omega_{UV}^+\} \subset  \{\omega^-,\omega^+\}$$

INSERER SCHEMA !! \\

Afin d'expliciter le décodage, introduisons la fonction :

$$\begin{array}{ccccc}
\varphi_{\mathbf{a},\mathbf{b},\mathbf{c},\mathbf{d}} & : & \F_q^{n/2} \times  \F_q^{n/2} & \to & \F_q^{n/2} \times  \F_q^{n/2} \\
 & & (\mathbf{x} , \mathbf{y}) & \mapsto &  (\mathbf{a}.\mathbf{x} + \mathbf{b}.\mathbf{y}, \mathbf{c}.\mathbf{x} + \mathbf{d}.\mathbf{y}) \\
\end{array}$$

Si cette fonction respecte les conditions sur les vecteurs $\mathbf{a},\mathbf{b},\mathbf{c},\mathbf{d}$ définies dans la définition \ref{UV-normalise}, on dit qu'elle est UV-normalisée. Dans ce cas on peut vérifier qu'elle est bijective d'inverse :

$$\begin{array}{ccccc}
\varphi^{-1}_{\mathbf{a},\mathbf{b},\mathbf{c},\mathbf{d}} & : & \F_q^{n/2} \times  \F_q^{n/2} & \to & \F_q^{n/2} \times  \F_q^{n/2} \\
 & & (\mathbf{x} , \mathbf{y}) & \mapsto &  (\mathbf{d}.\mathbf{x} - \mathbf{b}.\mathbf{y}, -\mathbf{c}.\mathbf{x} + \mathbf{a}.\mathbf{y}) \\
\end{array}$$

Ainsi, pour chaque vecteur $\mathbf{e}$ de $\F_q^n$, on peut associer deux vecteurs $\mathbf{e_U}$ et $\mathbf{e_V}$ de $\F_q^{n/2}$ tels que 
$$ (\mathbf{e_U},\mathbf{e_V}) = \varphi^{-1}_{\mathbf{a},\mathbf{b},\mathbf{c},\mathbf{d}}(\mathbf{e}).$$

\begin{propo} Inverser $f_{\omega,\mathbf{H}}$ pour un certain $\mathbf{s} \in F_q^{n-k}$ est équivalent à trouver $\mathbf{e} \in \F_q^n$ tel que:
$$ \mathbf{e}_U\mathbf{H}_U^T = \mathbf{s}^U \qquad \text{et} \qquad \mathbf{e}_V\mathbf{H}_V^T = \mathbf{s}^V $$
où $\mathbf{s} = (\mathbf{s}^U, \mathbf{s}^V)$ avec $\mathbf{s}^U \in \F_q^{n/2-k_U}$ et $\mathbf{s}^V \in \F_q^{n/2-k_V}$.
\end{propo}

\begin{proof}[Preuve] TODO
\end{proof}

Ainsi, on on aura : \\
\begin{flushleft}
\leftskip=2cm
\verb|InvertAlg|$(\mathbf{s},\mathbf{T}) : $\\
$\qquad (\mathbf{s}_U, \mathbf{s}_V) = s $\\
$\qquad \mathbf{e}_U = \verb|DECODE_U|(\mathbf{s}_U) $\\
$\qquad \mathbf{e}_V = \verb|DECODE_V|(\mathbf{s}_V)$ \\
$\qquad \verb|renvoie | \varphi_{\mathbf{a},\mathbf{b},\mathbf{c},\mathbf{d}}(\mathbf{e_U},\mathbf{e_V})$ \\
\leftskip=0cm
\vspace{0.1in}

\end{flushleft}
Si l'on choisit un algorithme générique pour \verb|DECODE_U| et \verb|DECODE_V|, alors nous obtiendrons un vecteur $\mathbf{e}$ de poids $\omega \ in \{\omega_{easy}^-,\omega_{easy}^+\}$. Non allons montrer comment utiliser les propriétés des codes $(U,U+V)$-généréralisés pour permettre un décodage hors de cet intervalle. 

\begin{remarque} Pour tout $\mathbf{e} = \varphi_{\mathbf{a},\mathbf{b},\mathbf{c},\mathbf{d}}(\mathbf{e_U},\mathbf{e_V})$, on a pour tout $i \in \{1,n/2\}$ :
\begin{center}

$\left \{
\begin{array}{rcl}
a_i\mathbf{e}_U(i) + b_i\mathbf{e}_V(i) &=& \mathbf{e}(i) \\
c_i\mathbf{e}_U(i) + d_i\mathbf{e}_V(i) &=& \mathbf{e}(i+n/2) 
\end{array}
\right.$
\end{center}

Choisir la valeur de $\mathbf{e}_U$ en fonction de la valeur de $\mathbf{e}_V$ nous permettras donc d'influer sur le poids de $\mathbf{e}$. On aura alors :

\begin{flushleft}
\leftskip=2cm
\verb|InvertAlg|$(\mathbf{s},\mathbf{T}) : $\\
$\qquad (\mathbf{s}_U, \mathbf{s}_V) = s $\\
$\qquad \mathbf{e}_V = \verb|DECODE_V|(\mathbf{s}_V)$ \\
$\qquad \mathbf{e}_U = \verb|DECODE_U|(\mathbf{s}_U, \mathbf{e}_V) $\\
$\qquad \verb|renvoie | \varphi_{\mathbf{a},\mathbf{b},\mathbf{c},\mathbf{d}}(\mathbf{e_U},\mathbf{e_V})$ \\
\leftskip=0cm
\vspace{0.1in}
\end{flushleft}

\end{remarque}

\begin{propo} Soit $\mathbf{e}_V$ une sortie de \verb|DECODE_V|. Soit \verb|DECODE_U| un algorithme prenant en entrée $\mathbf{s}_U$ et $\mathbf{e}_V$ et renvoyant $\mathbf{e}_U$ tel que $\mathbf{e}_U\mathbf{H}_U^T = \mathbf{s}^U$ et tel que pour $k_U$ positions de $\mathbf{e}_U$ 
\begin{center}
$\left \{
\begin{array}{rcl}
a_i\mathbf{e}_U(i) + b_i\mathbf{e}_V(i) &\neq& 0 \\
c_i\mathbf{e}_U(i) + d_i\mathbf{e}_V(i) &\neq& 0
\end{array}
\right.$
\end{center}
Alors $\mathbf{e} = \varphi_{\mathbf{a},\mathbf{b},\mathbf{c},\mathbf{d}}(\mathbf{e_U},\mathbf{e_V})$ a au moins $2k_U$ coordonnées non nulles. De plus les $n-k_U$ autres coordonnées sont uniformément distribuées sur $\F_q$. \\
On a alors 
$$ \mathbb{E}(|\mathbf{e}|) = \frac{q-1}{q}n + \frac{2k_U}{q} $$
et 
\begin{center}
$\omega^+_{UV} = $
$\left \{
\begin{array}{rcl}
&\frac{q-1}{q}n + \frac{2k}{q} & \;\; \text{ si } k \leq n/2 \\
&n & \quad \text{sinon}
\end{array}
\right.$
\end{center}
\end{propo}

\begin{proof}[Preuve]
TODO
\end{proof}


\begin{propo} Soit $\mathbf{e}_V$ une sortie de \verb|DECODE_V|. Soit \verb|DECODE_U| un algorithme prenant en entrée $\mathbf{s}_U$ et $\mathbf{e}_V$ et renvoyant $\mathbf{e}_U$ tel que $\mathbf{e}_U\mathbf{H}_U^T = \mathbf{s}^U$ et tel que pour $k_U$ positions de $\mathbf{e}_U$ 
\begin{center}
$\left \{
\begin{array}{rcl}
a_i\mathbf{e}_U(i) + b_i\mathbf{e}_V(i) &=& 0 \\
c_i\mathbf{e}_U(i) + d_i\mathbf{e}_V(i) &=& 0
\end{array}
\right.$
\end{center}
On a alors
\begin{center}
$\omega^-_{UV} = $
$\left \{
\begin{array}{rcl}
&\frac{q-1}{q}(n-2k) & \;\; \text{ si } k \leq n/(2q) \\
&\frac{2(q-1)^2}{(2q-1)q}(n-k) & \quad \text{sinon}
\end{array}
\right.$
\end{center}
\end{propo}

\begin{proof}[Preuve]
TODO
\end{proof}

On récapitule les différents cas dans la figure REF. \\
INSERER GRAPHIQUE \\
La connaissance de la trappe apporte donc bien un avantage puisqu'elle permet un décodage pour des erreurs de poids ne permettant pas de décodage générique. 

\begin{remarque} Fonction de hash
\end{remarque}

\subsection{Implémentation et choix de paramètres}
TODO \\
Détail de DECODE U et DECODE V + choix des paramètres et choix d'implémentation + résultats \\

\section{Uniformisation des signatures et syndromes}

\subsection{Une fuite d'information}
Afin d'assurer la sécurité du système, il est nécéssaire que les $\mathbf{e} \in f_{w,\mathbf{H}}^{-1}(\mathbf{s})$ ne révèlent pas d'information sur la structure du code (U,U+V)-généralisé utilisé. \\
Or, si la sortie $\mathbf{e_V}$ de \verb|DECODE_V| n'est pas uniforme, alors des corrélations entre les coordonnées $\mathbf{e}_i$ et $\mathbf{e}_{i+n/2}$ du vecteur $\mathbf{e}$. \\
Par exemple, prenons le cas où $q=3$, et où pour tout $i \in \{1,n/2\}$, $a_i = c_i = d_i = 1$ et $b_i = 0$, et où \verb|DECODE_V| est l'algorithme de Prange. \\
On a alors pour tout $\mathbf{e} = (\mathbf{e_U},\mathbf{e_U}+\mathbf{e_V})$
$$ |\mathbf{e_V}| = \# \; \{1  \leq i \leq n/2 \;|\; e_i \neq e_{i+n/2}\}$$

\begin{propo}
Si le vecteur $\mathbf{e_V}$ est obtenu par l'algorithme de Prange, alors il est de poids moyen $\frac{2}{3}(\frac{n}{2}-k_V)$.
\end{propo}

\begin{proof}[Preuve]
TODO
\end{proof}

Alors, pour tout $i \ in \{1,n/2\}$, on a :
$$ \mathbb{P}(\mathbf{e}_i \neq \mathbf{e}_{i+n/2}) = \frac{1}{n/2}\frac{2}{3}(n/2-k_V)(1+o(1))$$
PREUVE \\
En revanche, pour les autres paires $(i,j)$, on a :
$$ \mathbb{P}(\mathbf{e}_i \neq \mathbf{e}_{j}) = \frac{4wn - 3w^2-w}{n(n-1)}$$
Ces deux probabilités n'ont donc aucune raison d'être égales. On a donc une fuite d'information. En effet, dans la pratique et afin de cacher la structure, on effectue une permutation sur les coordonnées de $\mathbf{e}$ lors de la signature. Si un attaquant récupère suffisemment de signatures, il pourra donc en analysant la fréquence des $\mathbf{e}_i \neq \mathbf{e}_j$ retrouver cette permutation. Il est donc nécéssaire pour la sécurité du schéma de s'assurer de l'uniformité des sorties de l'algorithme \verb|sign|.

\subsection{La méthode du rejet}
Afin de s'assurer un $\mathbf{e}$ uniforme dans son ensemble, nous allons :
\begin{itemize}
\item choisir $\mathbf{e}_V$ de façon a ce qu'il soit uniforme dans son ensemble 
\item mettre des conditions de rejet sur $\mathbf{e}_U$ en fonction du poids de $\mathbf{e}_V$ afin de supprimer le biais sur l'ensemble 
$$ m_1(x) := \# \; \{1  \leq i \leq n/2 \;;\; |(x_i, x_{i+n/2})| = 1\}$$
\end{itemize}
Avant d'expliciter nos algorithmes, il est nécéssaire d'introduire quelques notations et définitions. \\

\begin{nota} On notera :
\begin{itemize}
\item $\mathbf{e}^{unif}$ la variable aléatoire tirée uniformément dans l'ensemble $S_{w,n}$
\item $\mathbf{e}_V^{unif}$ la variable aléatoire tirée uniformément dans les mots de $\F_q^{n/2}$ 
\item $\mathbf{e}_U^{unif}$ la variable aléatoire tirée uniformément dans les mots de $\F_q^{n/2}$ conditionné au vecteur $\e_V^{unif}$
\end{itemize}
\end{nota}


\begin{defi} (uniforme en poids et $m_1$-uniforme)
\begin{itemize}
\item \verb|DECODE_V| est dit uniforme en poids si ces sorties $\mathbf{e}_V$ sont telles que $\mathbb{P}(\mathbf{e}_V)$ n'est fonction que du poids de $\mathbf{e}_V$ quand $\mathbf{s}^V$ est tiré uniformément dans son ensemble.
\item \verb|DECODE_U| est dit $m_1$-uniforme si ces sorties $\mathbf{e}_U$ sont telles que $\mathbb{P}(\mathbf{e}_U\; |\;  \mathbf{e}_V)$ n'est fonction que du poids de $\mathbf{e}_V$ et de $m_1(\varphi(\mathbf{e}_U,\mathbf{e}_V))$.
\end{itemize}
\end{defi}

\begin{lemme} Soit $\mathbf{e}$ la sortie de \verb|InvertAlg| avec $\mathbf{s}_U$ et $\mathbf{s}_V$ choisis uniformément dans leurs ensembles. Soit \verb|DECODE_V| uniforme en poids et \verb|DECODE_U| $m_1$-uniforme. Si pour tout $y$ et $z$ 
$$|\mathbf{e}_V| \sim |\mathbf{e}_V^{unif}|\quad \text{et} \quad\mathbb{P}(m_1(\mathbf{e}) = z\; |\; |\mathbf{e}_V| = y) = \mathbb{P}(m_1(\mathbf{e}^{unif}) = z\; |\; |\mathbf{e}_V^{unif}| = y)$$
Alors
$$ \mathbf{e} \sim \mathbf{e}_V^{unif}.$$
\end{lemme}

\begin{proof}[Preuve] TODO
\end{proof}

Ainsi, pour que $\mathbf{e}$ soit uniformément distribué sur $S_\omega$, il suffit de choisir \verb|DECODE_V| de façon à ce que ses sorties soient uniforment sur $\F_q^{n/2}$ puis d'ajouter une condition de rejet sur les sorties de \verb|DECODE_U| de façon à ce que $m_1(\mathbf{e})$ conditionnée à $|\mathbf{e}_V|$ soit distribué comme $m_1(\mathbf{e}^{unif})$ conditionnée à $|\mathbf{e}_V^{unif}|$. \\
\begin{propo}
Soit l'algorithme :

\begin{flushleft}
\leftskip=2cm
\verb|DECODE_UV |$(\mathbf{H}_V,\mathbf{H}_V,\varphi,\mathbf{s}) : $\\
$\qquad \mathbf{e}_V \leftarrow \verb|DECODE_V |(\mathbf{H}_V,\mathbf{s}^V) $\\
$\qquad \verb|Faire|$ \\
$\qquad \qquad \mathbf{e}_U \leftarrow \verb|DECODE_U |(\mathbf{H}_U, \mathbf{s}^U, \varphi, \mathbf{e}_V) $\\
$\qquad \qquad \mathbf{e} \leftarrow \varphi(\mathbf{e}_U,\mathbf{e}_V)$ \\
$\qquad \verb|Tant que rand|([0,1]) \leq r(|\mathbf{e}_V|),m_1(\mathbf{e}))$\\
$\qquad \verb|retourner | \mathbf{e}$ \\
\leftskip=0cm
\vspace{0.1in}
\end{flushleft}
Où :
\begin{flushleft}

$$r(s,t) := \frac{1}{M(t)}\frac{q^{unif}(s,t)}{q(s,t)} $$
\vspace{0.1in}
$$q(s,t) := \mathbb{P}(m_1(\mathbf{e})=s\;|\;|\mathbf{e}_V|=t)$$ 
\vspace{0.1in}
$$q^{unif}(s,t) := \mathbb{P}(m_1(\mathbf{e}^{unif})=s\;|\;|\mathbf{e}^{unif}_V|=t)$$
\vspace{0.1in}
$$M(t) := \max_{0 \leq s \leq t} \frac{q^{unif}(s,t)}{q(s,t)}$$
\end{flushleft}
Alors si \verb|DECODE_V| est uniforme en poids et si \verb|DECODE_U| est $m_1$-uniforme, on a $\mathbf{e}\sim\mathbf{e}^{unif}$.
\end{propo}
\begin{proof}[Preuve]
TODO
\end{proof}
\subsection{Choix des algorithmes de décodage}
description explicite de \verb|DECODE_V| \\
description explicite de \verb|DECODE_U| \\
Application de la méthode du rejet selon ces choix et choix des distributions. 

\subsection{Estimation du nombre de rejet}
TODO \\

\subsection{Une famille de fonctions uniformément distribuée}
On a donc le point (2) de la definition des fonctions GPV qui est obtenu dans la section précédente. On va montrer le point (1), à savoir, notre famille de fonctions syndrômes est uniformément distribuée avec les codes (U,U+V)-généralisés \\

\section{Sécurité du schéma}
Deux problèmes : \\
- Distinction d'une matrice de parité d'un code (U,U+V)-généralisé permutée d'une matrice aléatoire \\
- Sécurité EUF-CMA du système si H ressemble à une matrice aléatoire \\

\subsection{Sécurité EUF-CMA}
Nous allons montrer que le schéma est sûr au sens EUF-CMA (Existential Unforgeability under Chosen Message Attacks). Pour cela nous ferons une réduction au problème DOOM.
\subsubsection{Définitions}

Soit $\mathcal{A}$ un adversaire ayant accès à $N_{sign}$ signatures de son choix.
\begin{defi} (Modèle de sécurité EUF-CMA). On définit 3 algorithmes :
\begin{multicols}{2}
\begin{flushleft}
$\verb|Init|$:\\
	$\quad (pk,sk) \leftarrow \verb|Gen|(1^{\lambda)}$ \\
	$\quad \mathbf{H}_{pk} \leftarrow pk$ \\
	$\quad (\varphi, \mathbf{H}_{U},\mathbf{H}_{V}) \leftarrow sk$ \\
	$\quad \verb|renvoie | \mathbf{H}_{pk}$ \\
\end{flushleft}
\begin{flushleft}
$\verb|Sign|(s)$: \\
	$\quad \mathbf{e} \leftarrow \mathcal{D}_{\varphi,\mathbf{H}_{U},\mathbf{H}_{V}}(s)$ \\
	$\quad$ \verb|renvoie | $\mathbf{e}$
\end{flushleft}
\begin{flushleft}
$\verb|Fin|(s,e)$: \\
	$\quad$ \verb|renvoie | $(\mathbf{e}\mathbf{H}_{pk}^T = s) \land (|\mathbf{e}| = \omega)$
\end{flushleft}
\end{multicols}
Le jeu EUF-CMA se déroule comme suit. $\mathcal{A}$ fait appel à \verb|Init|. Il peut ensuite faire $N_{sign}$ requêtes à \verb|sign|. Le jeu est dit réussi si $\mathcal{A}$ est capable de donner $(s,e)$ accepté par \verb|Fin| et tel que $s$ n'est jamais été demandé à \verb|Sign|. \\
On définit alors le succès EUF-CMA comme :
$$Succ^{EUF-CMA}_{Wave}(t,N_{sign}) := \max_{\mathcal{A};|A|\leq t}(\mathbb{P}(\mathcal{A}\text{ réussit le jeu EUF-CMA de Wave})).$$
Le protocole est alors sûr au sens EUF-CMA si ce succès est négligeable.
\end{defi}

Nous souhaitons donc montrer que notre système est sûr au sens EUF-CMA. Pour cela, nous allons dans la section suivante majorer ce succès par rapport au succès d'un problème connu, le problème DOOM.


\subsubsection{Réduction au problème DOOM}
\begin{defi} (Le problème DOOM). Soient des paramètres $(n,q,k,\omega,N)$, où $N$ est un entier. \\

\leftskip=1cm
\noindent$I$ : $\mathbf{H}$ une matrice uniforme de $\F_q^{(n-k)\times n}$ et $(\mathbf{s}_1,...,\mathbf{s}_N)$ une liste de $N$ syndromes. 

\noindent$Q$ : Décoder l'un des syndromes à la distance $w := \lfloor \omega n \rfloor$. 

\leftskip=0cm

On définit alors le succès de DOOM comme :
$$Succ^{DOOM(n,q,k,N)}(t) := \max_{\mathcal{A};|A|\leq t}(\mathbb{P}(\mathcal{A}(\mathbf{H},\mathbf{s}_1,...,\mathbf{s}_n)=\mathbf{e}\text{ tel que }$$
$$ \mathbf{eH}^T = \mathbf{s}_j \text{ pour un certain } j \in \{1,...,N\})).$$
\end{defi} 

La réduction à ce problème est naturelle pour un schéma de signature puisque JHFEKHZFKHFKZEHFILZEJHFKLZEJFHJ. \\ 
EXPLICATION INFORMELLE DE LA REDUCTION, POURQUOI ELLE VA MARCHER \\

Pour faire une preuve formelle de cette réduction, nous allons introduire un système de jeux qui nous permettra de réduire la sécurité d'un système à un problème $P$. Soit $\mathcal{A}$ un attaquant et $\mathcal{R}$ un rival. Soient $G_0, G_1, ...,G_N$ un ensemble de jeux et soit $\mathbb{P}(G_i)$ la probabilité pour $\mathcal{A}$ de répondre au défi posé par $\mathcal{R}$ pour le jeu $G_i$. $\mathbb{P}(G_0)$ est alors la probabilité de cassé le système considérer et $\mathbb{P}(G_N)$ la probabilité de répondre au problème $P$. \\
L'idée est de changer pas à pas les jeux $G_0$ à $G_N$ de façon à ce que :
$$\forall i \in {0,...,N-1}, |\mathbb{P}(G_i)-\mathbb{P}(G_i+1)| \in negl(\lambda) \Longrightarrow |\mathbb{P}(G_0)-\mathbb{P}(G_N)|  \in negl(\lambda)$$
où $\lambda$ est un paramètre de sécurité. Autrement dis, les changements sur les jeux ne changent qu'à un facteur négligeable près les probabilités de succès de l'attaquant $\mathcal{A}$. \\
Il n'est pas possible de changer le comportement de $\mathcal{A}$ puisqu'il est quelconque, en revanche nous pouvons modifier celui de $R$. \\
EVENTUELLEMENT METTRE LES 3 conditions mais je ne pense pas que ça soit nécessaire. \\

\begin{thm} (Réduction de sécurité). \\
Soit $N_{sign}$ le nombre de requêtes faites à l'oracle de signature. Soit $\lambda$ le paramètre de sécurité et $\lambda_0=\lambda + 2\log_2(N_{sign})$. On a :
$$Succ^{EUF-CMA}_{Wave}(t,N_{sign}) \leq 2Succ^{DOOM(n,q,k,N)}(t) + SMT$$
\end{thm}

\begin{proof}[Preuve]
\begin{itemize} On rappelle que correspond à notre jeu pour la sécurité EUF-CMA de Wave.
\item $G_1$ : Changer le jeu si lors d'un appelle à la fonction sign, deux $r$ identiques sont choisis pour un même message $m$. S0 + P(F) négligeable
\item $G_2$ : On crée une liste suffisemment grande de Lm, des sel, tous différent. Dans la fonction hash, si r est dans la liste, alors on choisit un e unifirme dans Sw, on renvoit son syndrome. e est stocké et au même couple (r, m) le même syndrome sera renvoyé. Si r n'est pas la dans liste, on renvoit un des syndromes de doom \\
Dans la fonction sign, on prend toujours le r suivant dans Lm. (ne pose pas de pb grace au passage à $G_1$ Ainsi dans sign, on ne signera jamais les syndromes de DOOM. On s'assure donc que le fait d'avoir un oracle à sign dans UEF-CMA ne change pas la sécu face à DOOM.
\item $G_3$ : Ici, on enlève l'utilisation de la trappe uniquement pour les syndromes non-DOOM, càd dans la fonction sign. On n'appelle plus la fonction de décodage D. A la place, on écupère le e stocké
\item $G_4$ : On remplace Hpk par H0. Pas de pb car plus de trappe
\item $G_5$ : On verifie que r n'est pas dans Lm, ainsi on est bien sûr que A a signé un message de DOOM ET qu'il connait nécessairement la trappe. 
\end{itemize}
\end{proof}

\subsubsection{Et la fonction de hachage ?}

\subsection{Indistinguabilité des codes (U,U+V)-généralisés}
Distinguer une matrice de parité d'un code (U,U+V)-généralisé d'une matrice de parité aléatoire. \\
Réduction à un problème NP-complet. \\
Utilisation de S et P pour masquer les propriétés de la matrice. \\

\section*{Conclusion}
\addcontentsline{toc}{section}{\protect\numberline{}Conclusion}

\newpage


\bibliographystyle{plain}
\bibliography{bibliography}

\end{document}